<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<style>
			table{border-collapse: collapse; border: 1px solid gray; border-width: 2px 1px 2px 1px;}
			th{border: 1px solid gray; padding: 4px; background-color: #ddd;}
			td{border: 1px solid gray; padding: 4px;}
			tr:nth-child(2n){background-color: #f8f8f8;}
			pre{border: 2px solid #d6d6d6; padding: 0px; border-radius: 3px;}
		</style>
	</head>
	<body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; ">
		<div>
			<h2 style="margin-top: 10px; font-size: 1em; color: rgb(0, 0, 0); font-family: 'PingFang SC', 'Microsoft YaHei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-style: initial; text-decoration-color: initial;"><a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/tsecer/p/10486224.html" style="color: rgb(0, 102, 170); text-decoration: none;"><span role="heading" aria-level="2" style="vertical-align: middle;">gdb如何调用被调试任务的特定函数</span></a>
			</h2>
			<div class="postText" style="font-size: 13.3333px; line-height: 1.8; color: rgb(0, 0, 0); font-family: 'PingFang SC', 'Microsoft YaHei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-style: initial; text-decoration-color: initial;">
				<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html" style="margin-bottom: 20px; word-break: break-word;">
					<p style="margin: 10px auto; text-indent: 0px;"><span style="font-size: x-large;"><strong><span style="color: rgb(153, 51, 0);">一、gdb中函数调用</span></strong></span><br />在gdb中，可以通过<br />call function(args……)<br />来调用一个函数，当然也可以使用print之类的函数来间接的调用一个函数，但是不管如何，它们最终都要求gdb来调用一个函数，执行该函数，取函数返回值等基本逻辑处理。现在想一下gdb是如何让被调试进程执行特定函数的，这里包含了参数的传递，返回值的提取，并且最为重要的是要保证只执行这个函数(也就是函数返回之后它如何收场)。特别是最后一个，函数如何结束的问题是一个比较棘手的问题，因为一个函数的返回点可能并不唯一，gdb没有办法在函数的最后加一个断点来等待执行完成，如果gdb不能在函数执行结束之后及时断住被调试任务，可能造成不可预知的灾难性后果。<br /><span style="color: rgb(153, 51, 0); font-size: x-large;">二、gdb实现</span><br />gdb中关于这个函数的实现位于<br />gdb-6.0\gdb\infcall.c<br />文件中的<br />call_function_by_hand (struct value *function, int nargs, struct value **args)<br />函数，具体函数细节我们就不详细分析了(当然不是因为我不懂)，这里只是大致说一下gdb是如何解决上面说的问题的。<br /><span style="font-size: large;"><strong><span style="color: rgb(153, 51, 0);">1、堆栈及参数如何确定</span></strong></span><br />对于函数来说，它首先要有一个堆栈，这个栈不仅包含了它自己使用的函数内堆栈，还要有自己的参数以及返回地址等信息，这些一般是由调用者代劳完成的，这是函数调用的规则。现在是gdb人工培育的一个函数调用，所以这个工作就理所当然的要由gdb来完成这个参数列表以及返回地址等函数使用的上下文的设置。这一点并不复杂，因为每种体系结构有自己的函数调用约定，例如，对于386来说，在进入函数之前，esp指向返回地址，esp+4为第一个参数，esp+8为第二个参数一次类推，当然有些比较特殊的调用需要在编译时声明，例如一些使用寄存器传递参数的函数调用，这些都会在可执行文件对应的调试信息中有保存，所以也不是什么难题，就像协议一样，照着协议的内容来做就不会有问题，因为关键就是一致嘛。<br />那么这个堆栈在哪里开呢？最为直观和简单的就是在当前调试的任务(线程)使用的堆栈栈顶之上开栈，这一点您也别大惊小怪，因为在Linux下的信号处理函数就是这么搞的，它就是使用了被中断线程的堆栈顶端的堆栈，所以这里gdb在被调试任务的栈顶建立自己的堆栈也是有情可原的，而且是最为直接的一种实现，这里不是高潮。<br /><span style="font-size: large;"><strong><span style="color: rgb(153, 51, 0);">2、如何优雅的执行并只执行这一个函数</span></strong></span><br />难点依然在于第一节中说的那个，函数执行完之后如何收场？在上面提到过，gdb要为函数设置参数和返回地址，不论函数内部有几个返回点，它返回之后总是会跳转到调用者给它提供的一个地址上来，所以我们可以在这个返回值上做文章，让它返回到一个特定的地址，然后我们在这个地址上打断点，从而可以知道该函数执行结束。使用gdb的断点功能，断点要设置到代码段中，即使设置到其它地方，我们如何保证这个断点不是其它线程正常路径下的一个函数调用而是我们手动调用函数的实现呢？所以这个返回地址的选择就非常重要，大家可以自己想一下设置到哪里。当然我是看了代码知道它，它是设置在了整个用户态程序的入口处，也就是从内核态到达用户态之后执行的第一条指令的地址，或者说这个程序的入口位置，这个位置在程序运行起来之后只会被被运行一次，而不会被其它任何的任务再调动，因为它是最为原始的入口，如果有人执行到这里，那么整个程序都要重新执行一次，所以这个是最为合适的一个位置。那么gdb如何知道这个位置呢？在elf文件中，在ELF文件的头部保存了这个文件的入口，我们随便找一个可执行文件，看一下它的入口<br />[tsecer@Harry localstatic]$ readelf -h&nbsp; /bin/cat&nbsp;<br />ELF Header:<br />&nbsp; Magic:&nbsp;&nbsp; 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00&nbsp;<br />&nbsp; Class:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELF32<br />&nbsp; Data:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&apos;s complement, little endian<br />&nbsp; Version:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 (current)<br />&nbsp; OS/ABI:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UNIX - System V<br />&nbsp; ABI Version:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<br />&nbsp; Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXEC (Executable file)<br />&nbsp; Machine:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Intel 80386<br />&nbsp; Version:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x1<br />&nbsp;&nbsp;<strong><span style="color: rgb(255, 0, 255);">Entry point address:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80490f0</span></strong><br />这里就是这个入口地址，gdb源代码中对于该地址的读取代码为<br />#define CALL_DUMMY_ADDRESS() (entry_point_address ())<br />/* Get current entry point address.&nbsp; */<br /><br />CORE_ADDR<br />entry_point_address (void)<br />{<br />&nbsp; return symfile_objfile ?&nbsp;<strong><span style="color: rgb(255, 0, 255);">symfile_objfile-&gt;ei.entry_poin</span></strong>t : 0;<br />}<br /><span style="font-size: x-large;"><strong><span style="color: rgb(153, 51, 0);">三、验证gdb实现</span></strong></span><br />[tsecer@Harry gdbentry]$ cat gdbentry.c<br />#include &lt;stdlib.h&gt;<br />#include &lt;stdio.h&gt;<br />void dumpmem(int * start, int len)/*<span style="color: rgb(255, 0, 0);">显示从start开始的len个整数</span>*/<br />{<br />int i ;<br />for(i =0 ; i &lt; len ; i++)<br />{<br />&nbsp;&nbsp;&nbsp; if(!(i&amp;0x3))<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printf(&quot;\n%#-08x:\t&quot;,start+i);<br />&nbsp;&nbsp;&nbsp; printf(&quot;%08x\t&quot;,start[i]);<br />}<br />printf(&quot;\n&quot;);<br />}<br />int handy(int * addr,int naptime)<br />{<br />int* myesp;<br />__asm__ __volatile__ (<br />&quot;movl %%esp,%0\n&quot;<br />:&quot;=&amp;r&quot;(myesp)<br />);/*<span style="color: rgb(255, 0, 0);">该汇编指令将esp地址放入myesp中，供下面打印堆栈内容</span>*/<br />printf(&quot;Dumping start from esp:\n&quot;);/*<span style="color: rgb(255, 0, 0);">这里显示gdb调动的堆栈内容</span>*/<br />dumpmem(myesp,16);<br />printf(&quot;Dumping entry from %#x is %#x end\n&quot;,addr,addr[0]);/*<span style="color: rgb(255, 0, 0);">显示整个可执行文件的入口处内容，修改为断点指令0xcc</span>*/<br />dumpmem(addr,1);<br />printf(&quot;enddumping&quot;);<br />sleep(naptime);<br />}<br />int main()<br />{<br />sleep(1000000);<br />}<br />[tsecer@Harry gdbentry]$ gcc -g -o gdbentry.c.exe gdbentry.c&nbsp;<br />[tsecer@Harry gdbentry]$ readelf -h gdbentry.c.exe&nbsp;<br />ELF Header:<br />&nbsp; Magic:&nbsp;&nbsp; 7f 45 4c 46 01 01 01 03 00 00 00 00 00 00 00 00&nbsp;<br />&nbsp; Class:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELF32<br />&nbsp; Data:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&apos;s complement, little endian<br />&nbsp; Version:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 (current)<br />&nbsp; OS/ABI:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UNIX - Linux<br />&nbsp; ABI Version:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<br />&nbsp; Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXEC (Executable file)<br />&nbsp; Machine:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Intel 80386<br />&nbsp; Version:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x1<br />&nbsp;&nbsp;<span style="color: rgb(255, 0, 255);">Entry point address:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80483a0</span>&nbsp;<strong><span style="color: rgb(255, 0, 0);">整个可执行文件的入口地址，这将会作为手动调用函数的返回地址</span></strong>。<br />&nbsp; Start of program headers:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 52 (bytes into file)<br />&nbsp; Start of section headers:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3780 (bytes into file)<br />&nbsp; Flags:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0<br />&nbsp; Size of this header:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 52 (bytes)<br />&nbsp; Size of program headers:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 (bytes)<br />&nbsp; Number of program headers:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8<br />&nbsp; Size of section headers:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 40 (bytes)<br />&nbsp; Number of section headers:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 38<br />&nbsp; Section header string table index: 35<br />[tsecer@Harry gdbentry]$ gdb gdbentry.c.exe&nbsp;<br />GNU gdb (GDB) Fedora (7.0-3.fc12)<br />Copyright (C) 2009 Free Software Foundation, Inc.<br />License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;<br />This is free software: you are free to change and redistribute it.<br />There is NO WARRANTY, to the extent permitted by law.&nbsp; Type &quot;show copying&quot;<br />and &quot;show warranty&quot; for details.<br />This GDB was configured as &quot;i686-redhat-linux-gnu&quot;.<br />For bug reporting instructions, please see:<br />&lt;http://www.gnu.org/software/gdb/bugs/&gt;...<br />Reading symbols from /home/tsecer/CodeTest/gdbentry/gdbentry.c.exe...done.<br />(gdb) b main<br />Breakpoint 1 at 0x804853c: file gdbentry.c, line 30.<br />(gdb) r<br />Starting program: /home/tsecer/CodeTest/gdbentry/gdbentry.c.exe&nbsp;<br /><br />Breakpoint 1, main () at gdbentry.c:30<br />30&nbsp;&nbsp;&nbsp; sleep(1000000);<br />Missing separate debuginfos, use: debuginfo-install glibc-2.11.2-3.i686<br />(gdb) call hand<br />handle_amd&nbsp;&nbsp;&nbsp; handle_intel&nbsp; handy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />(gdb)<strong><span style="color: rgb(255, 0, 255);">&nbsp;call handy(0x80483a0,2)</span></strong>&nbsp;<span style="font-size: large;"><strong><span style="color: rgb(255, 0, 0);">手动调用handy函数，该函数会显示函数入口处内容，可以看到，其中入口处已经被修改为intel的调试中断指令0xcc</span></strong></span>（int 3）<br />Dumping start from esp:<br /><br />0xbffff2b8:&nbsp;&nbsp;&nbsp; bffff2b8&nbsp;&nbsp;&nbsp; 00000010&nbsp;&nbsp;&nbsp; bffff2e8&nbsp;&nbsp;&nbsp; 080497ec&nbsp;&nbsp;&nbsp;&nbsp;<br />0xbffff2c8:&nbsp;&nbsp;&nbsp; bffff2d8&nbsp;&nbsp;&nbsp; 08048320&nbsp;&nbsp;&nbsp; bffff318&nbsp;&nbsp;&nbsp; bffff2b8&nbsp;&nbsp;&nbsp;&nbsp;<br />0xbffff2d8:&nbsp;&nbsp;&nbsp; bffff308&nbsp;&nbsp;&nbsp; 08048579&nbsp;&nbsp;&nbsp; bffff2e4&nbsp;&nbsp;&nbsp; 080483a0&nbsp;&nbsp;&nbsp;&nbsp;<br />0xbffff2e8:&nbsp;&nbsp;&nbsp; 080483a0&nbsp;&nbsp;&nbsp; 00000002&nbsp;&nbsp;&nbsp; 08048560&nbsp;&nbsp;&nbsp; 080483a0&nbsp;&nbsp;&nbsp;&nbsp;<br />Dumping entry from 0x80483a0 is<span style="color: rgb(255, 0, 255);">&nbsp;0x895eed<span style="font-size: x-large;"><strong>cc</strong></span></span><span style="font-size: x-large;"><strong>&nbsp;</strong></span>end<br /><br />0x80483a0:&nbsp;&nbsp;&nbsp; 895eedcc&nbsp;&nbsp;&nbsp;&nbsp;<br />$1 = 0<br />(gdb) x/x 0x80483a0<br />0x80483a0 &lt;_start&gt;:&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 0, 255);">0x895eed<span style="font-size: x-large;"><strong>31</strong></span></span><span style="font-size: large;"><strong><span style="color: rgb(255, 0, 0);">函数执行结束之后，这里可以看到此处恢复为代码段的原始值</span></strong></span>。<br />(gdb)&nbsp;<br /><span style="font-size: x-large;"><strong><span style="color: rgb(153, 51, 0);">四、为什么不是用/proc/pid/mem来看而是由handy来显示？</span></strong></span><br /><span style="color: rgb(255, 0, 0);">因为内核中限制了对进程mem文件的读取非常苛刻，只有进程自己或者它的调试进程可以读取，普通进程即使是root也不能读取其它进程的mem文件</span>。<br />linux-2.6.21\fs\proc\base.c<br />static ssize_t mem_read(struct file * file, char __user * buf,<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; size_t count, loff_t *ppos)<br />……<br />&nbsp;&nbsp;&nbsp; if (!MAY_PTRACE(task) || !ptrace_may_attach(task))<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto out;<br />#define MAY_PTRACE(task) \<br />&nbsp;&nbsp;&nbsp; (task == current || \<br />&nbsp;&nbsp;&nbsp; (task-&gt;parent == current &amp;&amp; \<br />&nbsp;&nbsp;&nbsp; (task-&gt;ptrace &amp; PT_PTRACED) &amp;&amp; \<br />&nbsp;&nbsp;&nbsp; &nbsp;(task-&gt;state == TASK_STOPPED || task-&gt;state == TASK_TRACED) &amp;&amp; \<br />&nbsp;&nbsp;&nbsp; &nbsp;security_ptrace(current,task) == 0))
					</p>
				</div>
			</div>
		</div>
	
<script type="text/javascript" language="javascript" src="jquery.js"></script>
<script type="text/javascript" language="javascript" src="itemlink.js"></script></body>
</html>