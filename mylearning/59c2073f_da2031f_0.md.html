<!DOCTYPE html>
<html>

	<head>
		<meta charset="utf-8">
		<meta name="Application" content="myBase Desktop">
		<title></title>
		<link rel="stylesheet" type="text/css" href="21a71439_1a20045d_0.css">
		<link rel="stylesheet" type="text/css" href="1ea0d80_15be03ec_0.css">

		<!-- highlight.js begins -->
		<script src="1ea0d80_3c6d0691_0.js" type="text/javascript"></script>
		<script>
			if(window.app && window.app.getConfigValByKey){
				hljs.configure({tabReplace: function(n){if(n<1 || n>32) n=4; var r=""; while(n-- > 0) r+=" "; return r;}(parseInt(window.app.getConfigValByKey("HtmlEdit.TabWidth")))});
			}
			hljs.initHighlightingOnLoad();
		</script>
		<!-- highlight.js ends -->

		<!-- MathJax begins -->
		<!-- DO NOT MAKE ANY CHANGES TO THE Begin/End COMMENT TAGS -->
		<!-- MathJax CDN hosted at cdn.mathjax.org will be shutting down on April 30, 2017. -->
		<!-- https://www.mathjax.org/cdn-shutting-down/ -->
		<!-- https://cdn.mathjax.org/mathjax/latest/MathJax.js -->
		<!-- https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js -->
		<!-- https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js -->
		<script type="text/x-mathjax-config">
			var nScale=150, nMinScale=50;
			if(MathJax && MathJax.Hub && MathJax.Hub.Config){
				MathJax.Hub.Config({

					tex2jax: {
						processEscapes: true
						, inlineMath: [ ['$', '$'] ]
						, displayMath: [ ['$$', '$$'] ]
						, skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a']
					}

					, CommonHTML: {scale: nScale, minScaleAdjust: nMinScale}
					, 'HTML-CSS': {scale: nScale, minScaleAdjust: nMinScale}
					, NativeMML: {scale: nScale, minScaleAdjust: nMinScale}
					, SVG: {scale: nScale, minScaleAdjust: nMinScale}
					, PreviewHTML: {scale: nScale, minScaleAdjust: nMinScale}

					, showProcessingMessages: true
				});
			}
		</script>
		<script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
		<!-- MathJax ends -->

	</head>

	<body>

	<article><h1 id="makefile">Makefile</h1>
<h3 id="3-2-1-makefile-">3.2.1 Makefile 规则</h3>
<hr>
<p>一个简单的Makefile 文件包含一系列规则,其样式如下:</p>
<pre><code>目标(target)...: 依赖(prerequisite)...
&lt;tab&gt;命令(command)
</code></pre><p> 目标(target)通常是要生成的文件名称,可以是可执行文件或者OBJ文件,也可以是一个执行动作的名称,比如&quot;clean&quot;.
 依赖是用来产生目标的材料(比如源文件),一个目标经常有几个依赖.
 命令是生成目标是的执行动作,一个规则可以包含几个命令,每个命令占一行.
注意:每个命令行前面必须是一个Tab字符,即命令行第一个字符是tab,这是容易出错的地方.
 通常,如果一个依赖发生了改变,就需要规则调用命令以更新或创建目标,但是并非所有的目标都有依赖.例如,目标&quot;clean&quot;的作用是清除文件,它没有依赖.
 规则一般是用于解释怎样和何时重建规则.make首先调用命令处理依赖,进而才能创建或更新目标.当然,一个规则也可以是用于解释怎样和何时执行一个动作,即打印提示信息.
 一个Makefile文件可以包含规则以外的其他文本,但一个简单的Makefile文件仅仅需要包含规则.虽然真正的规则比这里展示的示例复杂,但是格式是一样的.
 对于上面的Makefile,执行&quot;make&quot;命令时,仅当hello.c文件比hello文件新,才会执行命令&quot;arm-linux-gcc -o hello hello.c&quot; 生成可执行文件hello;如果还没有hello文件,这个命令也会执行.
 运行&quot;make clean&quot;时, 由于目标clean没有依赖,它的命令&quot;rm -f hello&quot;将被强制执行.</p>
<h3 id="3-2-2-makefile-">3.2.2 Makefile 文件里的赋值方法</h3>
<hr>
<p> 变量的定义语法形式如下:</p>
<pre><code>    immediate = deferred  #
    immediate ?= deferred
    immediate := immediated
    immediate += deferred or immediated
    define immediate
    deferred
    endef
</code></pre><p> 在GNU make中对变量的赋值有两种方式:延时变量, 立即变量.区别在于它们的定义方式和扩展方式不同,前者在这个变量使用时才扩展,意即当真正使用这个变量的值才确定; 后者在定义时它
的值就已经确定了.使用&quot;=&quot;, &quot;?=&quot;定义或使用 define 指令定义的变量是延时变量; 使用&quot;:=&quot;定义的变量是立即变量. 需要注意的一点是 &quot;?=&quot; 仅仅在变量还没定义的情况下有效, 即&quot;?=&quot;用来定
义第一次出现的延时变量.
 对于附加操作符&quot;+=&quot;, 右边变量如果在前面使用(:=)定义为立即变量则它也是立即变量, 否则均为延时变量.</p>
<h3 id="3-2-3-makefile-">3.2.3 Makefile 的常用函数</h3>
<hr>
<p>函数调用的格式如下:</p>
<pre><code>$(function arguments)
</code></pre><p> 这里&quot;function&quot;是函数名, &quot;arguments&quot; 是该函数的参数. 参数和函数名之间用空格或Tab隔开, 如果有多个参数, 它们之间用逗号隔开. 这些空格和逗号不是参数值的一部分. 
 内核的Makefile 中用的大量的函数, 现在介绍一些常用的.</p>
<h5 id="1-">1. 字符串替换和分析函数</h5>
<p> (1) $(subst from,to,text).
 在文本&quot;text&quot;中使用&quot;to&quot;替换每一处&quot;from&quot;.
 比如:</p>
<pre><code>    $(subst ee,EE,feet on the street)
</code></pre><p> 结果为 &quot;fEEt on the strEEt&quot;.
 (2) $(patsubst pattern,replacement,text).
 寻找&quot;text&quot;中符合格式&quot;pattern&quot;的字, 用&quot;replacment&quot;替换它们. &quot;pattern&quot;和&quot;replacement&quot;中可以使用通配符.
 比如:</p>
<pre><code class="lang-bash">    $(patsubst %.c,%.o,x.c.c bar.c)
</code></pre>
<p> 结果为: &quot;x.c.o bar.o&quot;.
 (3) $(strip string).
 去掉前导和结尾,并将中间多余的空格压缩为单个空格.
 比如: </p>
<pre><code>$(strip a    b c )
</code></pre><p>结果为: &quot;a b c&quot;.
(4) $(findstring find,in).
 在字符串&quot;in&quot;中搜寻&quot;find&quot;,如果找到,则返回值是&quot;find&quot;,否则返回值为空.
 比如:<br>    $(findstring a,a b c)
    $(findstring a,b c)
 结果为:&quot;a&quot; 和 &quot; &quot;.
(5) $(filter pattern...,text).
 返回在&quot;text&quot;中由空格隔开且匹配格式&quot;pattern...&quot;的字,去除不符合格式&quot;pattern...&quot;的字.
 比如:<br>    $(filter %.c %.s,foo.c bar.c baz.s ugh.h)
 结果为: &quot;foo.c bar.c baz.s&quot;.
(6) $(filter-out pattern...,text).
 返回在&quot;text&quot;中由空格隔开且不匹配格式&quot;pattern...&quot;的字,去除符合格式&quot;pattern...&quot;的字,它是函数filter的反函数.
 比如:<br>    $(filter-out %.c %.s,foo.c bar.c baz.s ugh.h)
 结果为: &quot;ugh.h&quot;.
(7) $(sort list).
 将&quot;list&quot;中的字按字母顺序排序, 并去掉重复的字. 输出由单个空格隔开的字的列表.
 比如:<br>    $(sort foo bar lose)
返回值是 &quot;bar foo lose&quot;.</p>
<ol start="2">
<li>文件名函数
 (1) $(dir names...).
  抽取&quot;names...&quot;中每一个文件名的路径部分,文件名的路径部分包括从文件名的首字符到最后一个斜杠(含斜杠)之前的一切字符.
  比如: 
 $(dir src/foo.c hacks)
  结果为: &quot;src/ ./&quot;.
  (2) $(notdir names...).
  抽取&quot;names...&quot;中每一个文件名中除路径部分外一切字符(真正的文件名).
  比如:<br>$(notdir src/foo.c hacks)
  结果为: &quot;foo.c hacks&quot;.
  (3) $(suffix names...).
  抽取&quot;names...&quot;中每一个文件名的后缀.
  比如:<br>$(suffix src/foo.c src-1.0/bar hacks)
  结果为: &quot;.c .c&quot;.
  (4) $(basename names...).
  抽取&quot;names...&quot;中每一个文件名中除后缀外一切字符.
  比如:<br>$(basename src/foo.c src-1.0/bar hacks)
  结果为: &quot;src/foo src-1.0/bar hacks&quot;.
  (5) $(addsuffix suffix,names...).
  参数&quot;names...&quot;是一系列的文件名,文件名之间用空格隔开;suffix是一个后缀名. 将suffix(后缀)的值附加在每一个独立文件名的后面, 完成后将文件名串联起来, 它们之间用单个空格隔开.
  比如:<pre><code>$(addsuffix .c,foo bar)
</code></pre> 结果为: &quot;foo.c bar.c&quot;.
 (6) $(addprefix prefix,names...).
 参数&quot;names...&quot;是一系列的文件名,文件名之间用空格隔开;prefix是一个前缀名. 将prefix(前缀)的值附加在每一个独立文件名的前面, 完成后将文件名串联起来, 它们之间用单个空格隔开.
 比如: <pre><code>$(addprefix src/,foo bar)
</code></pre> 结果为: &quot;src/foo src/bar&quot;.
 (6) $(wildcard patttern).
 参数&quot;patttern&quot;是一个文件名格式,包含有通配符(通配符和shell中的用法一样).函数wildcard的结果是一列和格式匹配且真实存在的文件的名称,文件名之间用一个空格隔开.
 比如:   若当前目录下有文件 1.c 2.c 1.h 2.h, 则:<pre><code>c_src := $(wildcard *.c)
</code></pre> 结果为: &quot;1.c 2.c&quot;.</li>
<li><p>其他函数
  (1) $(foreach var,list,text).
   前两个参数,&quot;var&quot;和&quot;list&quot;将首先扩展,最后一个参数&quot;text&quot;此时不扩展;接着,&quot;list&quot;扩展所得的每个字都赋给&quot;var&quot;变量; 然后&quot;text&quot;引用该变量进行扩展,因此&quot;text&quot;每次扩展都不相同.
   函数的结果是由空格隔开的&quot;text&quot;在&quot;list&quot;中多次扩展后,得到的新的&quot;list&quot;,就是说:&quot;text&quot;多次扩展的字串联起来,字与字之间由空格隔开,如此就产生了函数foreach的返回值.
   下面是一个简单的例子,将变量&quot;files&quot;的值设置为&quot;dirs&quot;中的所有目录下的所有文件的列表:
   比如:  </p>
<pre><code>dirs := a b c d
files := $(foreach dir,$(dirs),$(wildcard $(dir)/*))
</code></pre><p>这里 &quot;text&quot;是&quot;$(wildcard $(dir)/<em>) &quot;,它的扩展过程如下.
 第一个赋给变量dir的值是&quot;a&quot;,扩展结果为&quot;$(wildcard a/</em>)&quot;;
 第二个赋给变量dir的值是&quot;b&quot;,扩展结果为&quot;$(wildcard b/<em>)&quot;;
 第三个赋给变量dir的值是&quot;c&quot;,扩展结果为&quot;$(wildcard c/</em>)&quot;;
 如此继续扩展.
这个例子和下面的例子有共同的结果:</p>
<pre><code>files := $(wildcard a/* b/* c/* d/*)
</code></pre><p>  (2) $(if condition,then-part[,else-part]).
 首先把第一个参数&quot;condition&quot;的前导空格,结尾空格去掉,然后扩展.如果扩展为非空字符串,则条件&quot;condition&quot;为真;如果扩展为空字符串,则条件&quot;condition&quot;为假.
 如果条件&quot;condition&quot;为真,那么计算第二个参数&quot;then-part&quot;的值,并将该值作为整个函数if的值.
 如果条件&quot;condition&quot;为假,并且第三个参数存在,则计算第三个参数&quot;else-part&quot;的值,并将该值作为整个函数if的值;如果第三个参数不存在,函数if将什么也不计算,返回空值.<br> 
makefile $(if <condition>,<then-part> ) or $(if <condition>,<then-part>,<else-part> )
-如果<condition>为真(非空字符串),<then-part>为整个函数的返回值
-如果<condition>为假(空字符串),<else-part>为整个函数的返回值,如果此时<else-part>未定义,那么整个函数返回空字符串</p>
<p>(3) $(origin variable).
 变量&quot;variable&quot;是一个查询变量的名称,不是对该变量的引用.所以,不能采用&quot;$&quot;和圆括号的格式书写该变量,当然,如果需要使用非常量的文件名,可以在文件名中使用变量引用.
 函数origin的结果是一个字符串,该字符串变量的定义如下:</p>
<pre><code>undefined                        : 变量&quot;variable&quot;从来没有定义;
default                          : 变量&quot;variable&quot;是默认定义;
environment                      : 变量&quot;variable&quot;作为环境变量定义,选项&quot;-e&quot;没有打开;
environment override             : 变量&quot;variable&quot;作为环境变量定义,选项&quot;-e&quot;已打开;
file                             : 变量&quot;variable&quot;在Makefile中定义;
command line                     : 变量&quot;variable&quot;在命令行中定义;
override                         : 变量&quot;variable&quot;在Makefile中用override指令定义;
automatic                        : 变量&quot;variable&quot;是自动变量;
</code></pre><p>(4) $(shell command arguments).
 函数shell 是 make 与 外部环境的通信工具.函数shell的执行结果和在控制台上执行&quot;command arguments&quot;的结果相似.不过如果 &quot;command arguments&quot;的结果含有换行符(和回车符),
则在函数shell的返回结果中将它们处理为单个空格,若返回结果最后是换行符(和回车符),则被去掉.
 比如当前目录下有文件1.c 2.c 1.h 2.h, 则:
c_src := $(shell ls <em>.c)
 结果为: &quot;1.c 2.c&quot;.
 本节可以在阅读内核.bootloader,应用程序的Makefile文件时作为手册来查询.下面以options程序的Makefile作为例子进行演示, Makefile的内容如下:
file: Makefile
<code>`</code>bash
src     := $(shell ls </em>.c)
objs         := $(patsubst %.c,%.o, $(src))
test : $(objs)
gcc -o $@ $^</p>
</li>
</ol>
<p>%.o:%.c
    gcc -c -o $@ $^
clean:
    rm -f test *.o</p>
<pre><code> 上述Makefile中&quot;$@&quot;,&quot;$^&quot;,&quot;$&lt;&quot;称为自动变量.&quot;$@&quot;表示规则的目标文件名;  &quot;$^&quot;表示所有依赖的名字, 名字之间用空格隔开; 
&quot;$&lt;&quot;表示第一个依赖的文件名, &quot;%&quot;是通配符, 它和一个字符串中任意个数的字符相匹配; 
$@(目标):$^(依赖)
 
 options 目录下所有的文件为 main.c Makefile sub.c sub.h,下面一行行地分析.
 第2行src变量的值为 &quot;main.c sub.c&quot;.
 第3行objs变量的值为 &quot;main.o sub.o&quot;,是src变量经过patsubst函数处理后得到的.
 第5行实际上就是:
test : main.o sub.o
 目标test的依赖为main.o sub.o,开始时这两个文件还没生成,在执行生成test的命令之前先将main.o, sub.o作为目标查找到合适的规则,以生成main.o sub.o.
 第8,9行就是用来生成main.o, sub.o的规则.
对于main.o这个规则就是:

</code></pre><p>main.o:main.c
    gcc -c -o main.o($@) main.c($^)</p>
<pre><code> 对于sub.o这个规则就是:
</code></pre><p>sub.o:main.c
    gcc -c -o sub.o($@) sub.c($^)</p>
<pre><code>这样,test的依赖main.o,sub.o就生成了.
 第6行的命令是在生成main.o sub.o后得以执行的,
 在options目录下第一次执行make命令可以看到如下信息

</code></pre><p>gcc -c -o main.o main.c
gcc -c -o sub.o sub.c
gcc -o test main.o sub.o
<code>`</code></p>
<p><img src="C:\Users\guojicheng.RD\AppData\Roaming\Typora\typora-user-images\image-20220113090405851.png" alt="image-20220113090405851"></p>
<p><img src="C:\Users\guojicheng.RD\AppData\Roaming\Typora\typora-user-images\image-20220113090259853.png" alt="image-20220113090259853"></p>
<p><img src="C:\Users\guojicheng.RD\AppData\Roaming\Typora\typora-user-images\image-20220113090339409.png" alt="image-20220113090339409"></p>
</article>

	
<script type="text/javascript" language="javascript" src="jquery.js"></script>
<script type="text/javascript" language="javascript" src="itemlink.js"></script></body>
</html>
